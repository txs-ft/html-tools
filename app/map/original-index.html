<!-- åŸæœ¬çš„ã€éœ€è¦é‡æ§‹çš„index.html -->

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…­è¾¹å½¢ç½‘æ ¼åœ°å›¾ç¼–è¾‘å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
        }
        
        .container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            display: block;
            background: #0d1520;
            max-width: 100%;
            max-height: 100%;
            cursor: move;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
        }
        
        .info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 0.5s ease;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            z-index: 10;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-btn {
            background: linear-gradient(145deg, #2c3e50, #1c2833);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: linear-gradient(145deg, #3498db, #2980b9);
        }
        
        .control-btn.active {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
        }

        /* æ–‡ä»¶è¾“å…¥éšè— */
        .hidden-file-input {
            display: none;
        }
        
        .header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 5px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to right, #3498db, #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 16px;
            opacity: 0.8;
        }
        
        .mode-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(46, 204, 113, 0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .mode-indicator.edit {
            background: rgba(231, 76, 60, 0.3);
        }
        
        .instructions {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 16px;
            text-align: center;
            max-width: 90%;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>å…­è¾¹å½¢ç½‘æ ¼åœ°å›¾ç¼–è¾‘å™¨</h1>
        <div class="subtitle">è¯¾å ‚æ¸¸æˆå·¥å…· - ç‚¹å‡»é—¨æ¥å¯ç”¨/ç¦ç”¨é€šé“</div>
    </div>
    
    <div class="container">
        <canvas id="gridCanvas"></canvas>
        <div class="info">ç¼©æ”¾: é¼ æ ‡æ»šè½®æˆ–åŒæŒ‡æ‰‹åŠ¿ | å¹³ç§»: é¼ æ ‡æ‹–åŠ¨æˆ–å•æŒ‡æ»‘åŠ¨</div>
        <div class="mode-indicator" id="modeIndicator">æ¸¸æˆæ¨¡å¼</div>
        <div class="instructions" id="instructions">ç¼–è¾‘æ¨¡å¼å·²æ¿€æ´»ï¼ç‚¹å‡»é—¨æ¥å¯ç”¨/ç¦ç”¨é€šé“</div>
        
        <div class="controls">
            <button class="control-btn" id="loadMap" title="åŠ è½½åœ°å›¾">ğŸ“</button>
            <button class="control-btn" id="saveMap" title="ä¿å­˜åœ°å›¾">ğŸ’¾</button>
            <button class="control-btn" id="editMap" title="ç¼–è¾‘åœ°å›¾">ğŸ—º</button>
            <button class="control-btn" id="resetView" title="é‡ç½®è§†å›¾">â†º</button>
        </div>
        <!-- éšè—çš„æ–‡ä»¶è¾“å…¥å…ƒç´  -->
        <input type="file" id="fileInput" class="hidden-file-input" accept=".json">
    </div>

    <script>
        // é…ç½®å‚æ•°
        const BASE_HEX_SIZE = 60; // åŸºç¡€å…­è¾¹å½¢å¤§å°
        const MIN_SCALE = 0.3;    // æœ€å°ç¼©æ”¾æ¯”ä¾‹
        const MAX_SCALE = 10.0;   // æœ€å¤§ç¼©æ”¾æ¯”ä¾‹
        const SCALE_MULTIPLIER = 2.0; // ç¼©æ”¾é€Ÿåº¦ç³»æ•°

        /**
        * ä»£è¡¨å…­é‚Šå½¢æˆ¿é–“çš„ä¸€æ‰‡é–€
        */
        class HexDoor {
            /**
            * å‰µå»ºä¸€æ‰‡é–€
            * @param {number} x - é–€çš„Xåæ¨™
            * @param {number} y - é–€çš„Yåæ¨™
            * @param {number} angle - é–€çš„è§’åº¦(å¼§åº¦)
            * @param {HexRoom} room1 - ç¬¬ä¸€é–“æˆ¿
            * @param {HexRoom} room2 - ç¬¬äºŒé–“æˆ¿
            */
            constructor(x, y, angle, room1, room2) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.isUsable = false;
                this.room1 = room1;
                this.room2 = room2;
                this.hover = false;
            }

            /**
             * åœ¨ctxä¸­æŠŠé–€ç•«å‡ºä¾†
             * @param {CanvasRenderingContext2D} ctx - ç•«å¸ƒ
             * @param {string} mode - å½“å‰æ¨¡å¼ ('game' æˆ– 'edit')
             */
            draw(ctx, mode) {
                if (mode === 'game') {
                    // æ¸¸æˆæ¨¡å¼ä¸‹åªç»˜åˆ¶å¯ç”¨çš„é—¨
                    if (!this.isUsable) return;
                }
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // ç¼–è¾‘æ¨¡å¼ä¸‹å¤„ç†åŠé€æ˜æ•ˆæœ
                if (mode === 'edit') {
                    if (this.isUsable) {
                        ctx.globalAlpha = 1.0;
                    } else {
                        ctx.globalAlpha = 0.5;
                    }
                    
                    // é¼ æ ‡æ‚¬åœæ•ˆæœ
                    if (this.hover) {
                        ctx.shadowColor = '#f1c40f';
                        ctx.shadowBlur = 15;
                    }
                }
                
                ctx.font = `20px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ğŸšª', 0, 0);
                ctx.restore();
            }

            /**
             * æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨é–€ä¸Š
             * @param {number} x - é»æ“Šçš„Xåæ¨™
             * @param {number} y - é»æ“Šçš„Yåæ¨™
             * @param {number} threshold - é–¾å€¼è·é›¢
             * @returns {boolean} æ˜¯å¦é»æ“Šåˆ°é–€
             */
            isPointInside(x, y, threshold) {
                const dx = this.x - x;
                const dy = this.y - y;
                return Math.sqrt(dx * dx + dy * dy) < threshold;
            }

            /**
             * å‰µå»ºå„²å­˜ç”¨çš„æ•¸æ“š
             */
            createSaveData() {
                return {
                    "room1": { "r": this.room1.row, "c": this.room1.col },
                    "room2": { "r": this.room2.row, "c": this.room2.col }
                };
            }
        }

        /**
        * ä»£è¡¨ä¸€å€‹å…­é‚Šå½¢çš„æˆ¿é–“ï¼Œæœ€å¤šæœ‰å…­æ‰‡é–€
        */
        class HexRoom {
            /**
            * å‰µå»ºä¸€å€‹å…­é‚Šå½¢æˆ¿é–“
            * @param {number} col - åˆ—ç´¢å¼•
            * @param {number} row - è¡Œç´¢å¼•
            * @param {number} x - ä¸­å¿ƒé»Xåæ¨™
            * @param {number} y - ä¸­å¿ƒé»Yåæ¨™
            * @param {number} size - å…­é‚Šå½¢å¤§å°
            */
            constructor(col, row, x, y, size) {
                this.col = col;
                this.row = row;
                this.x = x;
                this.y = y;
                this.size = size;
                this.doors = [];
                this.id = `${String.fromCharCode(65 + col)}${row + 1}`;
                this.hover = false;
            }

            /**
             * åœ¨ctxä¸­æŠŠæˆ¿é–“ç•«å‡ºä¾†
             * @param {CanvasRenderingContext2D} ctx - ç•«å¸ƒ
             */
            draw(ctx) {
                // ç»˜åˆ¶å…­è¾¹å½¢
                const fillColor = this.hover ? '#e0f7fa' : '#ffffff';
                this.drawHexagon(ctx, this.x, this.y, this.size, fillColor, '#3498db');
                
                // ç¹ªè£½æˆ¿é–“ç·¨è™Ÿ
                ctx.fillStyle = '#2c3e50';
                ctx.font = `${Math.max(12, this.size/3)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);
                
                // é¼ æ ‡æ‚¬åœæ•ˆæœ
                if (this.hover) {
                    ctx.strokeStyle = '#f1c40f';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 3 * i;
                        const hx = this.x + this.size * Math.cos(angle);
                        const hy = this.y + this.size * Math.sin(angle);
                        if (i === 0) {
                            ctx.moveTo(hx, hy);
                        } else {
                            ctx.lineTo(hx, hy);
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            // ç»˜åˆ¶å•ä¸ªå…­è¾¹å½¢
            drawHexagon(ctx, x, y, size, fillColor, strokeColor) {
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const hx = x + size * Math.cos(angle);
                    const hy = y + size * Math.sin(angle);
                    if (i === 0) {
                        ctx.moveTo(hx, hy);
                    } else {
                        ctx.lineTo(hx, hy);
                    }
                }
                ctx.closePath();
                
                if (fillColor) {
                    ctx.fillStyle = fillColor;
                    ctx.fill();
                }
                
                if (strokeColor) {
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            /**
             * æ·»åŠ ä¸€æ‰‡é–€
             * @param {HexDoor} door - è¦æ·»åŠ çš„é–€
             */
            addDoor(door) {
                this.doors.push(door);
            }
            
            /**
             * æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨æˆ¿é–“ä¸Š
             * @param {number} x - é»æ“Šçš„Xåæ¨™
             * @param {number} y - é»æ“Šçš„Yåæ¨™
             * @returns {boolean} æ˜¯å¦é»æ“Šåˆ°æˆ¿é–“
             */
            isPointInside(x, y) {
                // ç°¡åŒ–ç‚ºæª¢æŸ¥é»åˆ°å…­é‚Šå½¢ä¸­å¿ƒçš„è·é›¢
                const dx = this.x - x;
                const dy = this.y - y;
                return Math.sqrt(dx * dx + dy * dy) < this.size;
            }
        }

        /**
         * ä»£è¡¨ä¸€å€‹å…­é‚Šå½¢ç¶²æ ¼åœ°åœ–
         */
        class HexMap {
            /**
            * å‰µå»ºä¸€å€‹å…­é‚Šå½¢ç¶²æ ¼åœ°åœ–
            * @param {number} cols - åˆ—æ•¸
            * @param {number} rows - è¡Œæ•¸
            * @param {number} hexSize - å…­é‚Šå½¢å¤§å°
            */
            constructor(cols, rows, hexSize) {
                this.cols = cols;
                this.rows = rows;
                this.hexSize = hexSize;
                this.hexWidth = hexSize * 2;
                this.hexHeight = hexSize * Math.sqrt(3);
                this.rooms = [];
                this.doors = [];
                
                this.createGrid();
            }

            /**
             * å‰µå»ºç¶²æ ¼å’Œé–€
             */
            createGrid() {
                // å‰µå»ºæ‰€æœ‰æˆ¿é–“
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        // è¨ˆç®—ä¸­å¿ƒé»åæ¨™
                        const x = c * this.hexWidth * 0.75 + this.hexWidth / 2;
                        const y = r * this.hexHeight + (c % 2) * (this.hexHeight / 2) + this.hexHeight / 2;
                        
                        const room = new HexRoom(c, r, x, y, this.hexSize);
                        this.rooms.push(room);
                    }
                }
                
                // å‰µå»ºé–€ï¼ˆç›¸é„°æˆ¿é–“ä¹‹é–“ï¼‰
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        // å…ˆè™•ç†æ©«è»¸ä¸Šçš„æˆ¿é–€
                        const room = this.getRoom(c, r);
                        if (c < this.cols - 1) {
                            if (c % 2 == 0) { // é›™æ•¸c
                                const se = this.getRoom(c + 1, r);
                                this.createDoorBetweenRooms(room, se, 0);
                                if (r > 0) { // éç¬¬ä¸€è¡Œ
                                    const ne = this.getRoom(c + 1, r - 1);
                                    this.createDoorBetweenRooms(room, ne, 0);
                                }
                            } else { // å–®æ•¸c
                                const ne = this.getRoom(c + 1, r);
                                this.createDoorBetweenRooms(room, ne, 0);
                                if (r < this.rows - 1) {
                                    const se = this.getRoom(c + 1, r + 1);
                                    this.createDoorBetweenRooms(room, se, 0);
                                }
                            }
                        }

                        // å†è™•ç†ç¸±è»¸ä¸Šçš„æˆ¿é–€
                        const s = this.getRoom(c, r + 1);
                        if (r < this.rows - 1) { // é€™ç°¡å–®ï¼šåªè¦ä¸æ˜¯æœ€åº•é‚£è¡Œæˆ¿é–“ï¼Œåªç®¡æ·»åŠ å—é–€ä¾¿å¯ï¼åŒ—é–€ä¸ç”¨ç®¡ï¼
                            this.createDoorBetweenRooms(room, s, 0); 
                        }
                        // ï¼ˆè¦–è¦ºä¸Šï¼Œé‚„æ˜¯ä¸è¦æŠŠğŸšªæ—‹è½‰äº†ï¼Œå¾ˆæ€ªï¼ï¼‰
                    }
                }
            }
            
            /**
             * åœ¨å…©å€‹æˆ¿é–“ä¹‹é–“å‰µå»ºä¸€æ‰‡é–€
             * @param {HexRoom} room1 - ç¬¬ä¸€å€‹æˆ¿é–“
             * @param {HexRoom} room2 - ç¬¬äºŒå€‹æˆ¿é–“
             * @param {number} [angle = 0] - é–€çš„è§’åº¦
             */
            createDoorBetweenRooms(room1, room2, angle = 0) {
                // è¨ˆç®—å…©å€‹æˆ¿é–“ä¹‹é–“çš„ä¸­é»
                const midX = (room1.x + room2.x) / 2;
                const midY = (room1.y + room2.y) / 2;
                
                // å‰µå»ºé–€
                const door = new HexDoor(midX, midY, angle, room1, room2);
                
                // æ·»åŠ åˆ°å…©å€‹æˆ¿é–“
                room1.addDoor(door);
                room2.addDoor(door);
                
                // æ·»åŠ åˆ°åœ°åœ–é–€åˆ—è¡¨
                this.doors.push(door);
            }
            
            /**
             * ç²å–æŒ‡å®šä½ç½®çš„æˆ¿é–“
             * @param {number} col - åˆ—ç´¢å¼•
             * @param {number} row - è¡Œç´¢å¼•
             * @returns {HexRoom} æˆ¿é–“å°è±¡
             */
            getRoom(col, row) {
                if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) {
                    return null;
                }
                return this.rooms[row * this.cols + col];
            }

            /**
             * åœ¨ctxä¸­æŠŠåœ°åœ–ç•«å‡ºä¾†
             * @param {CanvasRenderingContext2D} ctx - ç•«å¸ƒ
             * @param {string} mode - å½“å‰æ¨¡å¼ ('game' æˆ– 'edit')
             */
            draw(ctx, mode) {
                // ç¹ªè£½æ‰€æœ‰æˆ¿é–“
                this.rooms.forEach(room => room.draw(ctx));
                
                // ç¹ªè£½æ‰€æœ‰é–€ï¼ˆæ¨¡å¼è™•ç†åœ¨HexDoorå…§éƒ¨ï¼‰
                this.doors.forEach(door => door.draw(ctx, mode));
            }
            
            /**
             * æ¸…é™¤æ‰€æœ‰æ‚¬åœçŠ¶æ€
             */
            clearHover() {
                this.rooms.forEach(room => room.hover = false);
                this.doors.forEach(door => door.hover = false);
            }
        }

        class UIController {
            /**
             * åˆ›å»ºUIæ§åˆ¶å™¨
             * @param {HTMLCanvasElement} canvas - ç”»å¸ƒå…ƒç´ 
             * @param {function} drawCallback - ç»˜åˆ¶å›è°ƒå‡½æ•°
             * @param {function} createDefaultHexMap - åŠ è½½åœ°å›¾æ•°æ®çš„å›è°ƒå‡½æ•°
             */
            constructor(canvas, drawCallback, createDefaultHexMap) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.drawCallback = drawCallback;
                this.createDefaultHexMap = createDefaultHexMap;
                
                // çŠ¶æ€å˜é‡
                this.scale = 1.0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.startX = 0;
                this.startY = 0;
                this.isDragging = false;
                this.initialPinchDistance = null;
                this.initialScale = 1.0;
                this.mode = 'game'; // 'game' æˆ– 'edit'
                
                // é…ç½®å‚æ•°
                this.BASE_HEX_SIZE = 60;
                this.MIN_SCALE = 0.3;
                this.MAX_SCALE = 10.0;
                this.SCALE_MULTIPLIER = 2.0;
                
                // ç»‘å®šæ–¹æ³•ä»¥ç¡®ä¿æ­£ç¡®çš„thisä¸Šä¸‹æ–‡
                this.handleMouseDown = this.handleMouseDown.bind(this);
                this.handleMouseMove = this.handleMouseMove.bind(this);
                this.handleMouseUp = this.handleMouseUp.bind(this);
                this.handleWheel = this.handleWheel.bind(this);
                this.handleTouchStart = this.handleTouchStart.bind(this);
                this.handleTouchMove = this.handleTouchMove.bind(this);
                this.handleTouchEnd = this.handleTouchEnd.bind(this);
                this.handleClick = this.handleClick.bind(this);
                this.handleMouseMoveHover = this.handleMouseMoveHover.bind(this);
                this.adjustZoom = this.adjustZoom.bind(this);
                this.resetView = this.resetView.bind(this);
                this.initLoadMap = this.initLoadMap.bind(this);
                this.initSaveMap = this.initSaveMap.bind(this);
                this.editMap = this.editMap.bind(this);
            }
            
            /**
             * åˆå§‹åŒ–UIæ§åˆ¶å™¨
             */
            init() {
                // æ·»åŠ æ§ä»¶äº‹ä»¶
                document.getElementById('resetView').addEventListener('click', this.resetView);
                document.getElementById('loadMap').addEventListener('click', this.initLoadMap);
                document.getElementById('saveMap').addEventListener('click', this.initSaveMap);
                document.getElementById('editMap').addEventListener('click', this.editMap);
                
                // åŠ è½½åœ°å›¾æ•°æ®
                this.createDefaultHexMap();
                
                // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
                this.setupEventListeners();
                
                // åˆå§‹ç»˜åˆ¶
                this.draw();
                
                // 5ç§’åæ·¡å‡ºä¿¡æ¯æç¤º
                setTimeout(() => {
                    document.querySelector('.info').style.opacity = '0';
                }, 5000);
            }

            /**
             * åˆå§‹åŒ–åŠ è½½åœ°å›¾
             */
            initLoadMap() {
                // è§¦å‘éšè—çš„æ–‡ä»¶è¾“å…¥
                document.getElementById('fileInput').click();
            }

            /**
             * åˆå§‹åŒ–ä¿å­˜åœ°å›¾
             */
            initSaveMap() {
                // è·å–å½“å‰åœ°å›¾æ•°æ®
                const mapData = {
                    size: {
                        w: cols,
                        h: rows
                    },
                    doors: []
                };

                // æ”¶é›†æ‰€æœ‰é—¨çš„æ•°æ®
                if (hexMap) {
                    for (const door of hexMap.doors) {
                        // ä¸æ˜¯çœŸèƒ½ç”¨çš„é–€ï¼Œä¾¿ä¸ç”¨å­˜åˆ°JSONä¸­å»
                        if (!door.isUsable) continue;

                        mapData.doors.push({
                            room1: { r: door.room1.row, c: door.room1.col },
                            room2: { r: door.room2.row, c: door.room2.col }
                        })
                    }
                } else {
                    alert('åœ°å›¾æ ¼å¼é”™è¯¯ï¼Œä¸‹è½½å¤±è´¥');
                    return;
                }

                // åˆ›å»ºJSONæ–‡ä»¶å¹¶ä¸‹è½½
                const jsonStr = JSON.stringify(mapData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'hex-map.json';
                document.body.appendChild(a);
                a.click();
                
                // æ¸…ç†
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 0);
            }

            /**
             * åˆ‡æ¢åœ°å›¾ç¼–è¾‘æ¨¡å¼
             */
            editMap() {
                if (this.mode === 'game') {
                    this.mode = 'edit';
                    document.getElementById('editMap').classList.add('active');
                    document.getElementById('modeIndicator').textContent = 'ç¼–è¾‘æ¨¡å¼';
                    document.getElementById('modeIndicator').classList.add('edit');
                    document.getElementById('instructions').style.display = 'block';
                    
                    // 5ç§’åæ·¡å‡ºè¯´æ˜
                    setTimeout(() => {
                        document.getElementById('instructions').style.opacity = '0';
                    }, 5000);
                } else {
                    this.mode = 'game';
                    document.getElementById('editMap').classList.remove('active');
                    document.getElementById('modeIndicator').textContent = 'æ¸¸æˆæ¨¡å¼';
                    document.getElementById('modeIndicator').classList.remove('edit');
                    document.getElementById('instructions').style.display = 'none';
                    document.getElementById('instructions').style.opacity = '1';
                }
                
                // æ¸…é™¤æ‰€æœ‰æ‚¬åœçŠ¶æ€
                if (hexMap) hexMap.clearHover();
                this.draw();
            }
            
            /**
             * è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
             */
            setupEventListeners() {
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', this.handleMouseDown);
                this.canvas.addEventListener('mousemove', this.handleMouseMove);
                this.canvas.addEventListener('mouseup', this.handleMouseUp);
                this.canvas.addEventListener('mouseleave', this.handleMouseUp);
                this.canvas.addEventListener('wheel', this.handleWheel, { passive: false });
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                this.canvas.addEventListener('click', this.handleClick);
                this.canvas.addEventListener('mousemove', this.handleMouseMoveHover);
                
                // è§¦æ‘¸äº‹ä»¶
                this.canvas.addEventListener('touchstart', this.handleTouchStart, { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove, { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd);
                
                // çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', () => this.draw());
                
                // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
                document.getElementById('fileInput').addEventListener('input', (e) => {
                    const file = e.target.files[0];
                    console.log(file);
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            this.loadCustomMap(data);
                        } catch (error) {
                            console.error('è§£æJSONå¤±è´¥', error);
                            alert('åŠ è½½åœ°å›¾å¤±è´¥ï¼šJSONæ ¼å¼é”™è¯¯');
                        }
                    };
                    reader.readAsText(file);
                });
            }
            
            /**
             * åŠ è½½è‡ªå®šä¹‰åœ°å›¾æ•°æ®
             * @param {Object} data - åœ°å›¾æ•°æ®
             */
            loadCustomMap(data) {
                // éªŒè¯æ•°æ®æ ¼å¼
                if (!data.size || !data.size.w || !data.size.h || 
                    !Array.isArray(data.doors)) {
                    alert('åœ°å›¾æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                    return;
                }
                
                // æ›´æ–°å…¨å±€å°ºå¯¸
                cols = data.size.w;
                rows = data.size.h;
                
                // åˆ›å»ºæ–°åœ°å›¾
                hexMap = new HexMap(cols, rows, BASE_HEX_SIZE);
                
                // åˆ›å»ºæˆ¿é—´ä½ç½®æ˜ å°„è¡¨ (row-colä½œä¸ºé”®)
                const roomMap = new Map();
                hexMap.rooms.forEach(room => {
                    const key = `${room.row}-${room.col}`;
                    roomMap.set(key, room);
                });
                
                // å¤„ç†è‡ªå®šä¹‰é—¨æ•°æ®
                for (const doorData of data.doors) {
                    if (!doorData.room1 || !doorData.room2) continue;
                    
                    // è·å–ä¸¤ä¸ªæˆ¿é—´å¯¹è±¡
                    const room1Key = `${doorData.room1.r}-${doorData.room1.c}`;
                    const room2Key = `${doorData.room2.r}-${doorData.room2.c}`;
                    const room1 = roomMap.get(room1Key);
                    const room2 = roomMap.get(room2Key);
                    
                    if (!room1 || !room2) continue;
                    
                    // åœ¨hexMap.doorsä¸­æŸ¥æ‰¾å¯¹åº”çš„é—¨
                    const foundDoor = hexMap.doors.find(door => 
                        (door.room1 === room1 && door.room2 === room2) || 
                        (door.room1 === room2 && door.room2 === room1)
                    );
                    
                    // å¦‚æœæ‰¾åˆ°å¯¹åº”çš„é—¨ï¼Œè®¾ç½®ä¸ºå¯ç”¨
                    if (foundDoor) {
                        console.log(`Found door from ${foundDoor.room1.id} to ${foundDoor.room2.id}`);
                        foundDoor.isUsable = true;
                        
                        // åŒæ—¶æ›´æ–°ä¸¤ä¸ªæˆ¿é—´ä¸­çš„é—¨å¼•ç”¨
                        room1.doors.forEach(d => {
                            if (d === foundDoor) d.isUsable = true;
                        });
                        room2.doors.forEach(d => {
                            if (d === foundDoor) d.isUsable = true;
                        });
                    }
                }
                
                // é‡ç»˜
                this.draw();
                alert('åœ°å›¾åŠ è½½æˆåŠŸï¼');
                // é‡ç½®æ–‡ä»¶è¾“å…¥
                document.getElementById('fileInput').value = '';
            }
            
            /**
             * è°ƒæ•´ç¼©æ”¾
             * @param {number} delta - ç¼©æ”¾å˜åŒ–é‡
             */
            adjustZoom(delta) {
                const newScale = Math.min(this.MAX_SCALE, Math.max(this.MIN_SCALE, this.scale + delta));
                
                // ä»¥ç”»å¸ƒä¸­å¿ƒä¸ºç¼©æ”¾ä¸­å¿ƒ
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // è°ƒæ•´åç§»é‡ï¼Œä½¿ç¼©æ”¾ä¸­å¿ƒä¿æŒä¸å˜
                this.offsetX = centerX - (centerX - this.offsetX) * (newScale / this.scale);
                this.offsetY = centerY - (centerY - this.offsetY) * (newScale / this.scale);
                
                this.scale = newScale;
                this.draw();
            }
            
            /**
             * é‡ç½®è§†å›¾
             */
            resetView() {
                this.scale = 1.0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.draw();
            }
            
            // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
            handleMouseDown(e) {
                this.isDragging = true;
                this.startX = e.clientX - this.offsetX;
                this.startY = e.clientY - this.offsetY;
                this.canvas.style.cursor = 'grabbing';
            }
            
            // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
            handleMouseMove(e) {
                if (!this.isDragging) return;
                
                this.offsetX = e.clientX - this.startX;
                this.offsetY = e.clientY - this.startY;
                this.draw();
            }
            
            // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
            handleMouseUp() {
                this.isDragging = false;
                this.canvas.style.cursor = this.mode === 'edit' ? 'pointer' : 'grab';
            }
            
            // é¼ æ ‡æ»šè½®äº‹ä»¶
            handleWheel(e) {
                e.preventDefault();
                
                const delta = (e.deltaY > 0 ? -0.1 : 0.1) * this.SCALE_MULTIPLIER;
                const newScale = Math.min(this.MAX_SCALE, Math.max(this.MIN_SCALE, this.scale + delta));
                
                // è®¡ç®—ç¼©æ”¾ä¸­å¿ƒç‚¹
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // è°ƒæ•´åç§»é‡ï¼Œä½¿ç¼©æ”¾ä¸­å¿ƒä¿æŒä¸å˜
                this.offsetX = mouseX - (mouseX - this.offsetX) * (newScale / this.scale);
                this.offsetY = mouseY - (mouseY - this.offsetY) * (newScale / this.scale);
                
                this.scale = newScale;
                this.draw();
            }
            
            // è§¦æ‘¸å¼€å§‹äº‹ä»¶
            handleTouchStart(e) {
                e.preventDefault();
                
                if (e.touches.length === 1) {
                    // å•æŒ‡è§¦æ‘¸ - å¼€å§‹æ‹–åŠ¨
                    this.isDragging = true;
                    this.startX = e.touches[0].clientX - this.offsetX;
                    this.startY = e.touches[0].clientY - this.offsetY;
                } else if (e.touches.length === 2) {
                    // åŒæŒ‡è§¦æ‘¸ - å¼€å§‹ç¼©æ”¾
                    this.isDragging = false;
                    this.initialPinchDistance = this.getDistance(e.touches[0], e.touches[1]);
                    this.initialScale = this.scale;
                }
            }
            
            // è§¦æ‘¸ç§»åŠ¨äº‹ä»¶
            handleTouchMove(e) {
                e.preventDefault();
                
                if (this.isDragging && e.touches.length === 1) {
                    // å•æŒ‡ç§»åŠ¨ - æ‹–åŠ¨
                    this.offsetX = e.touches[0].clientX - this.startX;
                    this.offsetY = e.touches[0].clientY - this.startY;
                    this.draw();
                } else if (e.touches.length === 2) {
                    // åŒæŒ‡ç§»åŠ¨ - ç¼©æ”¾
                    const currentDistance = this.getDistance(e.touches[0], e.touches[1]);
                    
                    if (this.initialPinchDistance !== null) {
                        const scaleFactor = currentDistance / this.initialPinchDistance;
                        this.scale = Math.min(this.MAX_SCALE, Math.max(this.MIN_SCALE, this.initialScale * scaleFactor));
                        
                        // è®¡ç®—ç¼©æ”¾ä¸­å¿ƒç‚¹
                        const rect = this.canvas.getBoundingClientRect();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
                        const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
                        
                        // è°ƒæ•´åç§»é‡ï¼Œä½¿ç¼©æ”¾ä¸­å¿ƒä¿æŒä¸å˜
                        this.offsetX = centerX - (centerX - this.offsetX) * (this.scale / this.initialScale);
                        this.offsetY = centerY - (centerY - this.offsetY) * (this.scale / this.initialScale);
                        
                        this.draw();
                    }
                }
            }
            
            // è§¦æ‘¸ç»“æŸäº‹ä»¶
            handleTouchEnd(e) {
                if (e.touches.length === 0) {
                    // æ‰€æœ‰æ‰‹æŒ‡ç¦»å¼€
                    this.isDragging = false;
                    this.initialPinchDistance = null;
                } else if (e.touches.length === 1) {
                    // åªå‰©ä¸€æ ¹æ‰‹æŒ‡ï¼Œè½¬ä¸ºæ‹–åŠ¨æ¨¡å¼
                    this.isDragging = true;
                    this.startX = e.touches[0].clientX - this.offsetX;
                    this.startY = e.touches[0].clientY - this.offsetY;
                    this.initialPinchDistance = null;
                }
            }
            
            /**
             * è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
             * @param {Touch} touch1 - ç¬¬ä¸€ä¸ªè§¦æ‘¸ç‚¹
             * @param {Touch} touch2 - ç¬¬äºŒä¸ªè§¦æ‘¸ç‚¹
             * @returns {number} ä¸¤ç‚¹é—´è·ç¦»
             */
            getDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            /**
             * å¤„ç†ç‚¹å‡»äº‹ä»¶ï¼ˆç¼–è¾‘æ¨¡å¼ä¸‹ï¼‰
             * @param {MouseEvent} e - é¼ æ ‡äº‹ä»¶
             */
            handleClick(e) {
                if (this.mode !== 'edit' || !hexMap) return;
                
                // è·å–é¼ æ ‡åœ¨ç”»å¸ƒä¸Šçš„ä½ç½®
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // è½¬æ¢åˆ°åœ°å›¾åæ ‡ç³»ï¼ˆè€ƒè™‘ç¼©æ”¾å’Œå¹³ç§»ï¼‰
                const x = (mouseX - this.offsetX) / this.scale;
                const y = (mouseY - this.offsetY) / this.scale;
                
                // è®¾å®šä¸€ä¸ªé˜ˆå€¼ï¼ˆ20åƒç´ ï¼Œä½†è€ƒè™‘ç¼©æ”¾ï¼‰
                const threshold = 20 / this.scale;
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åˆ°äº†é—¨
                let clickedDoor = null;
                for (const door of hexMap.doors) {
                    if (door.isPointInside(x, y, threshold)) {
                        clickedDoor = door;
                        break;
                    }
                }
                
                if (clickedDoor) {
                    // åˆ‡æ¢é—¨çš„å¯ç”¨çŠ¶æ€
                    clickedDoor.isUsable = !clickedDoor.isUsable;
                    this.draw();
                }
            }
            
            /**
             * å¤„ç†é¼ æ ‡ç§»åŠ¨æ‚¬åœæ•ˆæœ
             * @param {MouseEvent} e - é¼ æ ‡äº‹ä»¶
             */
            handleMouseMoveHover(e) {
                if (!hexMap || this.mode !== 'edit') return;
                
                // è·å–é¼ æ ‡åœ¨ç”»å¸ƒä¸Šçš„ä½ç½®
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // è½¬æ¢åˆ°åœ°å›¾åæ ‡ç³»
                const x = (mouseX - this.offsetX) / this.scale;
                const y = (mouseY - this.offsetY) / this.scale;
                
                // è®¾å®šé˜ˆå€¼
                const doorThreshold = 20 / this.scale;
                const roomThreshold = BASE_HEX_SIZE / this.scale;
                
                // æ¸…é™¤æ‰€æœ‰æ‚¬åœçŠ¶æ€
                hexMap.clearHover();
                
                // æ£€æŸ¥é—¨æ‚¬åœ
                let hoverDetected = false;
                for (const door of hexMap.doors) {
                    if (door.isPointInside(x, y, doorThreshold)) {
                        door.hover = true;
                        hoverDetected = true;
                        this.canvas.style.cursor = 'pointer';
                        break;
                    }
                }
                
                // æ£€æŸ¥æˆ¿é—´æ‚¬åœ
                if (!hoverDetected) {
                    for (const room of hexMap.rooms) {
                        if (room.isPointInside(x, y)) {
                            room.hover = true;
                            hoverDetected = true;
                            this.canvas.style.cursor = 'pointer';
                            break;
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰æ‚¬åœåœ¨å¯äº¤äº’å…ƒç´ ä¸Š
                if (!hoverDetected) {
                    this.canvas.style.cursor = this.isDragging ? 'grabbing' : 'grab';
                }
                
                // é‡ç»˜ä»¥æ›´æ–°æ‚¬åœæ•ˆæœ
                this.draw();
            }
            
            /**
             * æ‰§è¡Œç»˜åˆ¶
             */
            draw() {
                // è®¾ç½®canvaså°ºå¯¸ä¸ºçª—å£å¤§å°
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // æ¸…é™¤ç”»å¸ƒ
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
                this.drawBackground();
                
                // è®¾ç½®ç¼©æ”¾å’Œå¹³ç§»
                this.ctx.save();
                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.scale, this.scale);
                
                // è°ƒç”¨å¤–éƒ¨ç»˜åˆ¶å›è°ƒï¼Œå¹¶ä¼ é€’å½“å‰æ¨¡å¼
                if (this.drawCallback) {
                    this.drawCallback(this.ctx, this.mode);
                }
                
                // æ¢å¤å˜æ¢
                this.ctx.restore();
            }
            
            /**
             * ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
             */
            drawBackground() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                ctx.fillStyle = '#0d1520';
                ctx.fillRect(0, 0, width, height);
                
                // ç»˜åˆ¶ç½‘æ ¼çº¿
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.1)';
                ctx.lineWidth = 1;
                
                // å‚ç›´çº¿
                for (let x = 0; x <= width; x += 30) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                
                // æ°´å¹³çº¿
                for (let y = 0; y <= height; y += 30) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            }
        }

        // å…¨å±€å˜é‡
        let canvas, ctx;
        let cols = 10, rows = 7; // é»˜è®¤å°ºå¯¸
        let hexMap = null;

        // åˆå§‹åŒ–
        window.onload = function() {
            canvas = document.getElementById('gridCanvas');
            ctx = canvas.getContext('2d');
            
            // åŠ è½½åœ°å›¾æ•°æ®çš„å‡½æ•°
            function createDefaultHexMap() {
                hexMap = new HexMap(cols, rows, BASE_HEX_SIZE);
                
                // é»˜è®¤å¯ç”¨ä¸€äº›é—¨
                const doorsToEnable = [
                    {room1: {c:0, r:0}, room2: {c:1, r:0}},
                    {room1: {c:0, r:0}, room2: {c:0, r:1}},
                    {room1: {c:1, r:0}, room2: {c:1, r:1}},
                    {room1: {c:0, r:1}, room2: {c:1, r:1}},
                    {room1: {c:1, r:1}, room2: {c:2, r:1}}
                ];
                
                for (const doorData of doorsToEnable) {
                    const room1 = hexMap.getRoom(doorData.room1.c, doorData.room1.r);
                    const room2 = hexMap.getRoom(doorData.room2.c, doorData.room2.r);
                    
                    if (room1 && room2) {
                        // æŸ¥æ‰¾è¿æ¥è¿™ä¸¤ä¸ªæˆ¿é—´çš„é—¨
                        const door = hexMap.doors.find(d => 
                            (d.room1 === room1 && d.room2 === room2) || 
                            (d.room1 === room2 && d.room2 === room1)
                        );
                        
                        if (door) {
                            door.isUsable = true;
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶å›è°ƒå‡½æ•°
            function drawCallback(ctx, mode) {
                if (hexMap) {
                    hexMap.draw(ctx, mode);
                }
            }
            
            // åˆ›å»ºUIæ§åˆ¶å™¨
            const uiController = new UIController(
                canvas, 
                drawCallback,
                createDefaultHexMap
            );
            
            // åˆå§‹åŒ–UIæ§åˆ¶å™¨
            uiController.init();
        };
        

    </script>
</body>
</html>